# **Chapter11. 리팩터링**

---

> **API** <br>
> 모듈과 함수과 같이 소프트웨어를 구성하는 **빌딩 블록들을 끼워 맞추는 연결부**

### 좋은 API는 데이터를 갱신하는 함수와 그저 조회만 하는 함수를 명확히 구분한다.

두 기능이 섞여있다면 리팩터링한다.

- 질의 함수와 변경함수 분리하기

값 하나 때문에 여러개로 나뉜 함수들은 리팩터링하여 하나로 합칠 수 있다.

- 함수 매개변수화하기

어떤 매개변수가 그저 함수의 동작모드를 전환하는 용도로 쓰일 땐 리팩터링한다.

- 플래그 인수 제거하기

데이터 구조가 함수 사이를 건너 다니면서 필요 이상으로 분해될 때는 리팩터링해 하나로 유지한다.

- 객채 통째로 넘기기

매개변수로 건네 피호출함수가 판단하게 할지, 호출 함수가 직접 정할지에 관해서는 상황에 따라 리팩터링한다.

- 매개변수를 질의 함수로 바꾸기
- 질의 함수를 매개 변수로 바꾸기

객체가 불변이길 바란다면 리팩터링한다.

- Setter 제거하기

호출자에 새로운 객체를 만들어 반환하려 할 때 일반적인 생성자의 능력만으로는 부족한 경우 리팩터링한다.

- 생성자를 팩터리 함수로 바꾸기

### 수많은 데이터를 받는 복잡한 함수르 잘게 쪼개는 문제를 다루는 리팩터링

함수를 객체로 변환하여, 함수 본문에서 함수를 추출하기 수월하게 한다.

- 함수를 명령으로 바꾸기

함수를 단순화하여 명령 객체가 더는 필요없어진다면 리팩터링해 함수로 되돌릴 수 있다.

- 명령을 함수로 바꾸기

<br>

## 11.1 질의 함수와 변경 함수 분리하기

### 질의 분리 (command-query separation)

- 질의 함수는 모두 부수 효과(겉보기 부수 효과)가 없어야한다.
- 장점 (이용할 때 신경 쓸 거리가 매우 적다)
    - 어느 때건 원하는 만큼 호출해도 아무 문제가 없다
    - 호출하는 문장의 위치를 호출하는 함수 안 어디로든 옮겨도 된다.
    - 테스트하기가 쉽다.

### 캐싱

- 객체의 상태를 변경하지만 객체 밖에서는 관찰할 수 없다.
- 즉, 겉보기 부수효과가 없으므로 질의 분리의 대상이 아니다.

| 배경 | 기준:  값을 반환하면서 부수효과도 있는 함수를 발견한 경우                                                                                                                                                                                                                                          |
|----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다. <br> 2. 새 질의 함수에서 부수효과를 모두 제거한다. <br> 3. 정적 검사를 수행한다. <br> 4. 원래 함수(변경 함수)를 호출하는 곳을 모두 찾아낸다. 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래 줄에 새로 추가한다. 하나 수정할 때마다 테스트한다. <br> 5. 원래 함수에서 질의 관련 코드를 제거한다. <br> 6. 테스트 한다. |
| 예시 | 1. 목록에서 해당하는 조건을 찾는 함수                                                                                                                                                                                                                                                     |

<br>

## 11.2 함수 매개변수화하기

| 배경 | 기준:  두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다른 경우                                                                                                                                                                                                                  |
|----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1.  비슷한 함수 중 하나를 선택한다. <br> 2. 함수 선언바꾸기로 리터럴들을 매개변수로 추가한다. <br> 3. 이 함수를 호출하는 곳 모두에 적절한 리터럴값을 추가한다. <br> 4. 테스트한다. <br> 5. 매개변수로 받은 값을 사용하도록 함수 본문을 수정한다. 하나 수정할 때마다 테스트한다. <br> 6. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다. 하나 수정할 때마다 테스트한다. |
| 예시 | 1. 연봉을 계산하는 함수                                                                                                                                                                                                                                          |

<br>

## 11.3 플래그 인수 제거하기

### 플래그 인수

- 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수
- 인수를 데이터가 아닌 제어 흐름을 결정하는 데 사용하는 경우
- 단점
    - 함수들의 기능 차이가 잘 드러나지 않는다.
    - 호출할 수 있는 함수들이 무엇이고, 어떻게 호출해야하는지를 이해하기 어려워진다.
    - 사용할 함수를 선택한 후에도 플래그 인수로 어던 값을 넘겨야 하는지 또 알아내야한다.
- 두 개 이상의 플래그 인수를 사용하는 함수
    - 플래그를 인수를 써야하는 합당한 근거가 될 수 있다. (가능한 조합의 수만큼 함수를 만들어야하기 때문)
    - 그러나 함수 하나가 너무 많은 일을 처리하고 있다는 신호 일 수도 있다.

| 배경 | 기준:  플래그 인수를 하나만 사용하고 있는 경우                                                                                   |
|----|---------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성한다. <br> 2. 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다. |
| 예시 | 1. 플래그 인수를 사용하는 함수 <br> 2. 매개 변수를 까다로운 방식으로 사용할 때                                                             |

<br>

## 11.4 객체를 통째로 넘기기

### 레코드를 인수로 넘기기

- 장점
    - 변화에 대응하기 쉽다.
    - 매개변수 목록이 짧아져서 함수 사용법을 이해하기 쉽다.
    - 같은 데이터를 사용하는 함수끼리의 로직 중복을 제거할 수 있다.
- 수행하지 않는 경우
    - 함수가 레코드에 의존하기를 원치 않는 경우
    - 레코드와 함수가 서로 다른 모듈에 속한 경우
- 사례
    - (악취) 어떤 객체로부터 값 몇 개를 얻은 후 그 값들로만 무언가를 하는 로직
        - 해결 방안: 로직을 객체 안으로 넣어야함
        - 매개변수 객체 만들기 후(산재한 수많은 데이터 더미를 새로운 객체로 묶은 후) 해당 리팩터링 진행
    - 한 객체가 제공 하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많은 경우
        - 해당 기능만 따로 묶어서 클래스로 추출
    - 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러개를 건네는 경우
        - 데이터 여러개 대신 this(자신의 참조)만 건네도록 수정

| 배경 | 기준:  하나의 레코드에서 값 두어개를 가져와 인수로 넘기는 경우                                                                                                                                                                                                               |
|----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 매개변수들을 원하는 형태로 받는 빈 함수를 만든다. <br> 2. 새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다. <br> 3. 정적 검사를 수행한다. <br> 4. 모든 호출자가 새 함수를 사용하게 수정한다. 하나씩 수정하며 테스트하자. <br> 5. 호출자를 모두 수정했다면 원래 함수를 인라인한다. <br> 6. 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영한다. |
| 예시 | 1. 실내온도 모니터링 시스템  <br> 2. 새 함수를 다른 방식으로 만들기                                                                                                                                                                                                        |

<br>

## 11.5 매개변수를 질의 함수로 바꾸기

### 매개변수 목록

- 의미
    - 함수의 변동 요인을 모아놓은 곳 (= 함수의 동작에 변화를 줄 수 있는 일차적인 수단)
    - 중복을 피하고, 짧을 수록 좋다
- 중복
    - 피호출함수가 스스로 쉽게 결정할 수 잇는 값을 매개변수로 건네는 것도 일종의 중복이다
- 한계
    - 매개변수의 유무에 따라 값을 결정하는 책임 주체가 달라진다.
    - 피호출 함수가 그 역할을 수행하기에 적합한 경우, 책임 소재를 피호출함수로 옮기는 쪽을 선호
- 질의 함수로 바꾸지 말아야하는 경우
    - 매개 변수 제거 시 피호출 함수에 원치않는 의존성이 생길 때
- 안심하고 바꿀 수 있는 경우
    - 매개변수의 값을 다른 매개변수에 질의해서 얻을 수 있는 경우
- 주의 사항
    - 대상 함수가 참조 투명해야한다
        - 참조 투명: 함수에 똑같은 값을 건네 호출하면 항상 똑같이 동작한다
        - 즉, 매개변수를 없애는 대신 가변 전역 변수를 이용하면 안된다.

| 배경 | 기준:  매개변수의 값을 다른 매개변수에 질의해서 얻을 수 있는 경우                                                                                                                                |
|----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 필요하다면 대상 매개변수의 값을 계산하는 코드를 별도 함수로 추출해놓는다. <br> 2. 함수 본문에서 대상 매개변수로의 참조를 모두 찾아서 그 매개변수의 값을 만들어주는 표현식을 참조하도록 바꾼다. 하나 수정할 때마다 테스트한다. <br> 3. 함수 선언 바꾸기로 대상 매개변수를 없앤다. |
| 예시 | 1. 다른 리팩터링을 수행한 뒤 특정 매개변수가 더 이상 필요없어진 경우                                                                                                                              |

<br>

## 11.6 질의 함수를 매개변수로 바꾸기

### 참조를 매개변수로 바꾸기

- 적용 상황
    - 전역 변수를 참조하는 경우
    - 제거하길 원하는 원소를 참조하는 경우
- 발생 원인과 고려 사항
    - 코드의 의존 관계를 바꾸려 할 때
    - 어느 쪽에 의존성을 둘 것인지에 대한 문제이기때문에, 영원히 옳은 결정은 없다.
    - 프로그램을 더 잘 이해하게 됐을 때 더 나은 쪽으로 개선하기 쉽게 설계해야한다
- 참조 투명성
    - 의미
        - 똑같은 값을 건네면 매번 똑같은 결과를 내는 함수
    - 문제점
        - 참조 투명하지 않은 원소에 접근하는 경우, 참조 투명성을 잃게 된다.
    - 해결 방안
        - 해당 원소를 매개변수로 바꾸면 해결 가능 (단, 책임이 호출자로 옮겨진다)
    - 장점
        - 프로그램의 일부를 순수함수로 바꿀 수 있다
        - 결과적으로 테스트하거나 다루기 쉬워진다.
    - 단점
        - 어떤 값을 제공할지 호출자가 알아내야한다. (호출자가 복잡해짐)
- 결론
    - 프로그램의 발전과 요구사항 변경에 따라 균형점이 달라질 수 있으니 적절히 활용해야 함

| 배경 | 기준:  참조를 풀어내는 책임을 호출자로 옮겨야하는 경우                                                                                                                                                  |
|----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 변수 추출하기로 질의 코드를 함수 본문의 나머지 코드와 분리한다. <br> 2. 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별도 함수로 추출한다. <br> 3. 방금 만든 변수를 인라인하여 제거한다. <br> 4. 원래 함수도 인라인한다. <br> 5. 새 함수의 이름을 원래 함수의 이름으로 고쳐준다. |
| 예시 | 1. 실내온도 제어 시스템                                                                                                                                                                   |

<br>

## 11.7 Setter 제거하기

### Setter가 없는 객체 (= 필드가 불변인 경우)

- 해당 필드는 오직 생성자에서만 설정됨
- 수정하지 않겠다는 의도가 명백함
- 변경 가능성이 봉쇄됌

| 배경 | 기준: <br> 1. 사람들이 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때 <br> 2. 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때                                                                                                                                  |
|----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 설정해야할 값을 생성자에서 받지않는다면 그 값을 받을 매개변수를 생성자에 추가한다. 그런 다음 생성자안에서 적절한 세터를 호출한다. <br> 2. 생성자 밖에서 세터를 호출하는곳을 찾아 제거하고, 대신 새로운 생성자를 사용하도록 한다. 하나 수정할 때 마다 테스트한다. <br> 3. 세터 메서드를 인라인한다. 가능하다면 해당 필드를 불변으로 만든다. <br> 4. 테스트한다. |
| 예시 | 1. 사람 클래스                                                                                                                                                                                                              |

<br>

## 11.8 생성자를 팩터리 함수로 바꾸기

### 생성자

- 객체를 초기화하는 특별한 용도의 함수
- 문제점
    - 생성자의 이름이 고정되어, 기본 이름보다 더 적절한 이름이 있어도 사용할 수 없다.
    - 일반 함수가 오길 기대하길 기대하는 자리에서 사용하기 어렵다.
    - (자바): 서브 클래스의 인스턴스나 프록시를 반환할 수 없다
- 해결 방안
    - 팩터리 함수

| 배경 | 기준:  생성자 대신 객체를 초기화할 함수가 필요한 경우                                                                                                                 |
|----|-------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 팩터리 함수를 만든다. 팩터리 함수의 본문에서는 원래의 생성자를 호출한다. <br> 2. 생성자를 호출하던 코드를 팩터리 함수 호출로 바꾼다. <br> 3. 하나씩 수정할 때마다 테스트한다. <br> 4. 생성자의 가시 범위가 최소가 되돌고 제한한다. |
| 예시 | 1. 직원 유형                                                                                                                                        |

<br>

## 11.9 함수를 명령으로 바꾸기

### 명령 객체

- 의미
    - 함수만을 위한 객체 안으로 함수를 캡슐화한 것
- 구성
    - 대부분 메서드 하나로 구성
- 목적
    - 해당 메서드를 요청해 실행하는 것
- 장점
    - 평범한 함수 메커니즘보다 유연하게 함수를 제어하고 표현할 수 있다.
    - 되돌리기와 같은 보조 연산을 제공할 수 있다.
    - 생명주기를 더 정밀하게 제어하는 데 필요하는 매개변수를 만들어주는 메서드 제공할 수 있다.
    - 상속과 훅을 이용해 사용자 맞춤형으로 만들 수도 있다.
    - 일급함수를 지원하지 않는 프로그래밍 언어를 사용할 때, 일급 함수의 기능 대부분을 흉내낼 수 있다.
    - 중첩함수를 지원하지 않는 언어를 사용할 때, 메서드와 필드를 이용해 복잡한 함수를 잘게 쪼갤 수 있다.
- 단점
    - 복잡성을 키운다

그러나, 일급 함수와 명령 중 하나를 선택하라면 95%확률로 일급 함수를 사용한다.

| 배경 | 기준:  명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요한 경우                                                                                                |
|----|-----------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 대상 함수의 기능을 옮길 빈 클래스를 만든다. 클래스 이름은 함수 이름에 기초해 짓는다. <br> 2. 방금 생성한 빈 클래스로 함수를 옮긴다. <br> 3. 함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다. |
| 예시 | 1. 점수 계산 함수                                                                                                                             |

## 11.10 명령을 함수로 바꾸기

| 배경 | 기준:  명령의 로직이 크게 복잡하지 않은 경우                                                                                                                                                                                                                                                                                                                                                                     |
|----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함께 함수로 추출한다. <br> 2. 명령의 실행 함수가 호출하는 보조 메서드들 각각을 인라인한다. <br> 3. 함수 선언 바꾸기를 적용하여 생성자의 매개변수 모두를 명령의 실행 메서드로 옮긴다. 명령의 실행 메서드에서 참조하는 필드들 대신 대응하는 매개변수를 사용하게끔 바꾼다. 하나씩 수정할 때마다 테스트한다. <br> 4. 명령의 실행 메서드에서 참조하는 필드들 대신 대응하는 매개 변수를 사용하게끔 바꾼다. 하나씩 수정할 때마다 테스트한다. <br> 5. 생성자 호출과 명령의 실행 메서드 호출을 호출자 안으로 인라인한다. <br> 6. 테스트한다. <br> 7. 죽은 코드 제거하기로 명령 클래스를 없앤다. |
| 예시 | 1. 임금계산기                                                                                                                                                                                                                                                                                                                                                                                       |

<br>

## 11.11 수정된 값 반환하기

| 배경 | 기준:  값 하나를 계산한다는 분명한 목적이 있는 경우                                                                                                                                                                                                                                    |
|----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 함수가 수정된 값을 반환하게 하여 호출자가 그 값을 자신의 변수에 저장하게 한다. <br> 2. 테스트한다. <br> 3. 피호출 함수 안에 반환할 값을 가리키는 새로운 변수를 선언한다. <br> 4. 테스트한다. <br> 5. 계산이 선언과 동시에 이뤄지도록 통합한다. (즉, 선언 시점에 계산 로직을 바로 실행해 대입한다.) <br> 6. 테스트한다. <br> 7. 피호출 함수의 변수 이름을 새 역할에 어울리도록 바꿔준다. <br> 8. 테스트한다. |
| 예시 | 1. GPS 위치 목록으로 다양한 계산을 수행하는 코드                                                                                                                                                                                                                                    |

<br>

## 11.12 오류 코드를 예외로 바꾸기

### 오류 코드

- 함수를 호출하면 언제든 오류가 반환될 수 있다.
- 오류코드를 일일이 검사하거나 오류를 식별해 콜스택 위로 던져야한다.

### 예외

- 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘
- 특징
    - 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파되므로, 오류 코드보다 간편하다.
    - 독자적인 흐름이 있어서 관련 없는 로직의 경우 오류 발생에 따른 대처 코드가 불필요하다.
- 주의 사항
    - 정확히 예상 밖의 동작일 때만 쓰여야한다.
    - 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야한다.
- 경험 법칙
    - 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램이 정상 동작할지 따져본다.
    - 정상 동작하지 않는 다면 예외 대신 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리한다.

| 배경 | 기준:  프로그램의 정상 동작 범주에 들지 않는 오류를 나타내는 경우                                                                                                                                                                                                                                                                                                       |
|----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 콜스택 상위에 해당 예외를 처리할 예외 핸들러를 작성한다. <br> 2. 테스트한다. <br> 3. 해당 오류 코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법을 찾는다. <br> 4. 정적 검사를 수행한다. <br> 5. catch절을 수정하여 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않은 예외는 다시 던진다. <br> 6. 테스트한다. <br> 7. 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정한다. 하나씩 수정할 때마다 테스트한다. <br> 8. 모두 수정했다면 그 오류 코드를 콜스택위로 전달하는 코드를 모두 제거한다. 하나씩 수정할 때마다 테스트한다. |
| 예시 | 1. 전역 테이블에서 배송지의 배송규칙을 알아내는 코드                                                                                                                                                                                                                                                                                                               |

<br>

## 11.13 예외를 사전확인으로 바꾸기

| 배경 | 기준:  함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있는 경우                                                                                                                                |
|----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 예외를 유발하는 상황을 검사할 수 있는 조건문을 추가한다. catch 블록의 코드를 조건문의 조건절 중 하나로 옮기고, 남은 try 블록의 코드를 다른 조건절로 옮긴다. <br> 2. catch블록에서 어서션을 추가하고 테스트한다. <br> 3. try문과 catch블록을 제거한다. <br> 4.테스트한다. |
| 예시 | 1. 자원 풀 클래스                                                                                                                                                                     |
