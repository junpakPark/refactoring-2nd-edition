# Chapter8. 기능 이동

***

> 요소를 다른 컨텍스트(클래스나 모듈 등)로 옮기는 일 역시 리팩터링의 중요한 축이다.

- 함수 옮기기
- 필드 옮기기

옮기기는 문장 단위에서도 이뤄진다.

- (함수 안) 문장을 함수로 옮기기
- (함수 밖) 문장을 호출한 곳으로 옮기기
- (같은 함수 안에서 이동)문장 슬라이드하기
- (중복 제거) 인라인 코드를 함수 호출로 바꾸기

반복문과 관련된 리팩터링

- 반복문 쪼개기
- 반복문을 파이프라인으로 바꾸기

그외

- 죽은 코드 제거하기

<br>

## 8.1 함수 옮기기

> 프로그래밍 언어들은 저마다의 모듈화 수단을 제공하며, <br>
> 각각의 수단이 함수가 살아 숨 쉬는 컨텍스트를 만들어준다.

- OOP의 핵심 모듈화 컨텍스트: 클래스

모듈성

- 모듈화가 얼마나 잘되어 있느냐를 의미
- 프로그램을 수정할 때, 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력
- 좋은 소프트웨어 설계의 핵심
- 서로 연관된 요소들을 함께 묶고 요소 사이의 연결관계를 쉽게 찾고 이해할 수 있도록 해야함

<br>

함수를 복사할 때,

- 소스 함수: 원래의 함수
- 타깃 함수: 복사해서 만든 새로운 함수

| 배경 | 기준: 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 비교하여 판단한다.                                                                                                                                                                                                                                                                                          |
|----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 선택한 함수와 그 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소들 중에서도 함께 옮겨야할 게 있는 지 고민해본다.<br> 2. 선택한 함수가 다형 메서드인지 확인한다.<br> 3. 선택한 함수를 타깃 컨텍스트로 복사한다. 타깃 함수가 새로운 터전에 잘 자리잡도록 다듬는다.<br> 4. 정적 분석을 시행한다.<br> 5. 소스 컨텍스트에서 타깃 함수를 참조할 방법을 찾아 반영한다.<br> 6. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.<br> 7. 테스트한다.<br> 8. 소스 함수를 인라인할지 고민해본다.                     |
| 예시 | 1. 중첩 함수를 최상위로 옮기기                                                                                                                                                                                                                                                                                           <br> 2. 다른 클래스로 옮기기 |

<br>

## 8.2 필드 옮기기

데이터 구조

- 적합한 경우: 동작 코드가 자연스럽게 단순하고 직관적으로 짜여짐
- 부적합한 경우
    - 이해하기 어려운 코드가 만들어짐
    - 데이터 구조 자체도, 프로그램이 어떤일을 하는지 파악하기 어렵게 함

<br>

경험 및 기술이 쌓여도 초기 설계에서는 실수가 빈번함

- 도메인 지식이 쌓이면 더 적합한 데이터 구조가 보임
- 현재 데이터 구조가 적절치 않은 경우, 곧바로 수정해야 함

<br>

필드 옮기기

- 필드를 옮길 때, 그 필드를 함수를 같이 옮길 가능성이 높다 → 더 큰 리팩터링의 일환으로 수행
- 당장 필드를 옮길 수 없는 경우, 사용 패턴을 먼저 리팩터링한 후 필드를 옮겨준다.

| 배경 | 기준: 현재 데이터 구조가 적절치 않은 경우                                                                                                                                                                                                                               |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다. <br> 2. 테스트한다. <br> 3. 타깃 객체에 필드(와 접근자 메서드들)를 생성한다. <br> 4. 정적 검사를 수행한다. <br> 5. 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다. <br> 6. 접근자들이 타깃 필드를 사용하도록 수정한다. <br> 7. 테스트한다. <br> 8. 소스 필드를 제거한다. <br> 9. 테스트한다.                      |
| 예시 | 1. 고객 클래스와 계약 클래스                                                                                                                                                                                                                  <br> 2. 공유 객체로 이동하기 |

<br>

## 8.3 문장을 함수로 옮기기

중복 코드 제거

- 코드를 건강하게 관리하는 가장 효과적인 방법 중 하나
- 호출하는 곳이 아무리 많더라도, 한 곳만 수정하면 됨

| 배경 | 기준: 문장들이 피호출 함수의 일부라는 확신이 있는 경우                                                                                                                                                                                                                                                                                                                                                                                                            |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기를 적용해 근처로 옮긴다. <br> 2. 타깃 함수를 호출하는 곳이 한 곳뿐이라면, 단순히 소스 위치에서 해당 코드를 잘라내어 피호출함수로 복사하고 테스트한다. 이 경우라면 나머지 단계는 무시한다. <br> 3. 호출자가 둘 이상이면, 호출자 중 하나에서 ‘타깃 함수 호출 부분과 그 함수로 옮기려는 문장들을 함께’ 다른 함수로 추출한다. 추출한 함수에 기억하기 위운 임시 이름을 지어준다. <br> 4. 다른 호출자모두가 방금 추출한 함수를 사용하도록 수정한다. 하나씩 수정할 때마다 테스트한다. <br> 5. 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인한 후 원래 함수를 제거한다. <br> 6. 새로운 함수의 이름을 원래 함수의 이름으로 바꿔준다. |
| 예시 | 1. 사진 관련 데이터를 HTML로 내보내는 코드                                                                                                                                                                                                                                                                                                                                                                                                                |

<br>

## 8.4 문장을 호출한 곳으로 옮기기

함수

- 프로그래머가 쌓아 올리는 추상화의 기본 빌딩 블록

<br>

추상화

- 경계를 항상 완벽하게 나눌 수 없음
- 코드 베이스의 기능 범위 변경에 따라 하나의 일만 하던 함수가 두개 이상의 일을 수행하는 경우 발생

<br>

문장을 호출한 곳으로 옮기기

- 작은 변경의 경우
    - 문장을 호출한 곳으로 옮기기
- 호출자와 호출 대상의 경계가 명확하지 않은 경우
    - 더 적합한 경계 설정하기
        - 함수를 먼저 인라인하기
        - 문장 슬라이드 하기
        - 함수 추출하기

| 배경 | 기준: 여러 곳에서 사용하던 함수가 일부 호출자에게는 다르게 동작해야하는 경우                                                                                                                                                                                                        |
|----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 호출자가 한두 개뿐이고 피호출함수도 간단한 단순한 상황이면, 피호출 함수의 처음(혹은 마지막) 줄을 잘라내어 호출자로 복사해 넣는다.(필요하면 적당히 수정한다.) 테스트만 통과하면 이번 리팩터링은 여기서 끝이다. <br> 2. 이동하지 ‘않길’ 원하는 모든 문장을 함수로 추출한 다음 검색하기 쉬운 임시 이름을 지어준다. <br> 3. 원래 함수를 인라인한다. <br> 4. 추출된 함수의 이름을 원래 함수의 이름으로 변경한다. |
| 예시 | 1. 호출자가 둘뿐인 단순한 상황                                                                                                                                                                                                                                 |

<br>

## 8.5 인라인 코드를 함수 호출로 바꾸기

함수

- 여러 동작을 하나로 묶어줌
- 함수의 이름: 코드의 동작보다 목적을 말해주기 때문에 코드를 함수를 활용하면 이해하기가 더 쉬워짐
- 중복 제거
    - 비슷한 코드를 일일이 찾아 수정하는 대신 함수 하나만 수정
    - 우연히 비슷한 코드가 만들어진 경우는 예외

<br>

인라인 코드를 대체할 함수

- 존재 하는 경우: 인라인 코드를 함수 호출로 바꾸기
- 존재 하지 않는 경우: 함수 추출하기

| 배경 | 기준: 인라인 코드 대신 함수 이름을 넣어도 말이 되는 경우      |
|----|----------------------------------------|
| 절차 | 1. 인라인 코드를 함수 호출로 대체한다. <br> 2. 테스트한다. |
| 예시 | _                                      |

<br>

## 8.6 문장 슬라이드하기

관련된 코드끼리 모으기

- 장점: 이해하기 쉬움
- 다른 리팩터링의 준비 단계 (관련 있는 코드를 모아서 함수로 추출하기 등)

<br>

문장 슬라이드를 할 수 없는 경우

- 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로는 이동할 수 없다.
- 코드 조각을 참조하는 요소의 뒤로는 이동할 수 없다.
- 코드 조각에서 참조하는 요소를 수정하는 문장을 건너뛰어 이동할 수 없다.
- 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다.

| 배경 | 기준: 관련된 코드가 흩어져 있는 경우                                                                                                                                         |
|----|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 코드 조각(문장들)을 이동할 목표 위치를 찾는다. 코드 조각의 원래 위치와 목표 위치 사이의 코드들을 훑어보면서, 조각을 모으고 나면 동작이 달라지는 코드가 있는지 살핀다. <br> 2. 코드 조각을 원래 위치에서 잘라내어 목표 위치에 붙여 넣는다. <br> 3. 테스트한다. |
| 예시 | 1. 조건문이 있을 때의 슬라이드                                                                                                                                            |

<br>

## 8.7 반복문 쪼개기

리팩터링과 최적화

- 반복문이 여러가지 일을 수행하는 경우
    - 원인: 성능상의 이점을 누리기 위해
    - 단점: 코드 수정이 어려움 (코드가 하는 일을 모두 파악해야만 수정 가능)
- 최적화는 코드를 깔끔하게 정리한 이후에 수행하자
    - 긴 리스트를 반복하더라도 병목으로 이어지는 경우는 드뭄
    - 반복문을 다시 합치기는 쉬움
    - 다른 더 강력한 최적화를 적용할 수 있는 길을 여러주기도 함

<br>

반복문 쪼개기

- 코드를 사용하기 쉬워짐
    - 한 가지 값만 사용하는 경우: 값을 바로 반환
    - 여러 일을 수행하는 경우: 구조체 반환 혹은 지역 변수 활용
- 서로 다른 일들이 한 함수에서 이뤄지고 있는 신호
    - 반복문 쪼개기와 함수 추출하기는 연이어서 수행하는 일이 잦다.

| 배경 | 기준: 하나의 반복문이 여러가지 일을 수행하는 경우                                                                                      |
|----|-------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 반복문을 복제해 두 개로 만든다. <br> 2. 반복문이 중복되어 생기는 부수효과를 파악해서 제거한다. <br> 3. 테스트한다. <br> 4. 완료됐으면, 각 반복문을 함수로 추출할지 고민해본다. |
| 예시 | 1. 전체 급여와 가장 어린 나이를 계산하는 코드                                                                                       |

<br>

## 8.8 반복문을 파이프라인으로 바꾸기

컬렉션 파이프라인

- 처리 과정을 일련의 연산으로 표현할 수 있음
- 각 연산은 컬렉션을 입력받아 다른 컬렉션을 반환함
- 논리를 파이프라인으로 표현하면 이해하기가 쉬워짐

| 배경 | 기준: 반복문 중 파이프라인을 적용할 수 있는 경우                                                                                                                                                                                                   |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다. <br> 2. 반복문의 첫 줄부터 시작해서, 각각의 단위를 적절한 컬렉션 파이프라인 연산으로 대체한다. 이때, 컬렉션 파이프라인 연산은 이전에 만든 반복문 컬렉션 변수에서 시작하여, 이전 연산의 결과를 기초로 연쇄적으로 수행된다. 하나를 대체할 때마다 테스트한다. <br> 3. 반복문의 모든 동작을 대체했다면 반복문 자체를 지운다. |
| 예시 | 1. 회사의 지점 사무실 정보에서 특정 위치에 자리한 사무실의 도시명과 전화번호 반환하는 코드                                                                                                                                                                           |

<br>

## 8.9 죽은 코드 제거하기

코드의 양

- 쓰이지 않는 코드가 있어도 시스템이 느려지거나 메모리를 많이 잡아 먹지 않는다
- 최신 컴파일러가 사용하지 않는 코드를 알아서 제거해준다
- 그러나 더 이상 사용되지 않는 코드는 지워야한다.

<br>

죽은 코드

- 소프트웨어의 동작을 이해하는 데 커다란 걸림돌이 될 수 있음
- 스스로 ‘절대 호출되지 않으니 무시해도 된다!’ 라는 신호를 주지 않기 때문
- 다른 개발자가 코드의 동작을 이해하거나, 디버깅 하는데 시간을 허비하게 되기 때문
- 나중에 다시 필요해질 경우, 버전관리 시스템을 이용해 복구 가능하다

| 배경 | 기준: 더 이상 사용되지 않는 코드가 존재하는 경우                                                                                         |
|----|----------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 죽은 코드를 외부에서 참조할 수 있는 경우라면(예를 들어, 함수 하나가 통째로 죽은 경우) 혹시라도 호출하는 곳이 잇는지 확인한다. <br> 2. 없다면 죽은 코드를 제거한다. <br> 3. 테스트한다. |
| 예시 | _                                                                                                                    |
