# Chapter3. 코드에서 나는 악취

***

리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지 않게 중요하다

리팩터링이 필요한, 때로는 아주 절실한 코드들에 일정한 패턴이 있다.
‘냄새’란 표현을 통해 이 시점을 설명한다.

하지만 리팩터링을 언제 멈춰야할지를 판단하는 기준은 제시하지 않을 것이다.
이는 각자 경험을 통해 감을 키워야 한다.

## Mysterious Name (기이한 이름)

‘이름’은 코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나다. 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어
있을 가능성이 높다.

그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

| 리팩터링 기법                                       | 상황                                                                            |
|-----------------------------------------------|-------------------------------------------------------------------------------|
| - 함수 선언 바꾸기 <br> - 변수 이름 바꾸기 <br> - 필드 이름 바꾸기 | 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 없는 경우 이름을 바꾼다. |   |

## Duplicate Code (중복 코드)

코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야하는 부담이 생긴다
그중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야한다.

이렇게 똑같은 코드 구조가 여러 곳에서 반복된다면, 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

| 리팩터링 기법     | 상황                                                                          |
|-------------|-----------------------------------------------------------------------------|
| - 함수 추출하기   | 한 클래스의 두 메서드가 똑같은 표현식을 사용하는 경우, <br> 양쪽 모두 추출한 메서드를 호출하게 바꾼다                |
| - 문장 슬라이드하기 | 코드가 비슷하긴 한데 완전히 똑같지 않다면, 비슷한 부분을 한 곳에 모아 <br> 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다. |
| - 메서드 올리기   | 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있다면, <br>  각자 따로 호출되지 않도록 부모로 옮긴다.            |

## Long Function (긴 함수)

짧은 함수로 구성된 코드 베이스의 특징:

- 오랜 기간 잘 활용된다
- 코드가 끝없이 위임하는 방식으로 작성되어 있다.
    - 그래서 얼핏 흝으면 연산하는 부분이 하나도 없어보인다.
- 간접 호출의 효과를 누릴 수 있다.
    - 코드를 이해하기 쉽다
    - 코드를 공유하기 쉽다
    - 코드를 선택하기 쉽다

짧은 함수를 꺼렸던 이유:

| 원인                                                    | 대안                                                                                                    |
|-------------------------------------------------------|-------------------------------------------------------------------------------------------------------|
| - 예전 언어는 서브루틴을 호출하는 비용이 컸다                            | 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다.                                                                  |
| - 코드를 읽는 사람 입장에서 함수가 하는 일을 파악하기 위해 왔다 갔다 해야하므로 부담이 된다 | - 함수 호출부와 선언부 사이를 빠르게 이동하거나 호출과 선언을 동시에 보여주는 개발 환경을 활용할 수 있다. <br> - 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. |

함수 추출 원칙:

- 무엇을 하는지 잘 설명해주지 못할수록 함수로 만든다.
    - 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려있는 경우가 많다.
- 함수의 목적(의도)과 구현 코드의 괴리가 클수록 함수로 만든다.
- 원래 코드보다 길어지더라도 함수를 뽑는다
    - 코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는게 좋다.
- 뽑아낸 함수 이름은 동작 방식이 아닌 **의도**가 드러나게 짓는다.

| 리팩터링 기법                                                  | 상황                                                                                                                          |
|----------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| -함수 추출하기                                                 | 함수를 짧게 만드는 작업의 99%이다. 함수 본문에서 따로 묶어 빼내면 <br> 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.                                                 |
| - 임시 변수를 질의 함수로 바꾸기 <br> - 매개변수 객체 만들기 <br> - 객채 통째로 넘기기 | 함수가 임시 변수와 매개변수를 많이 사용한다면 추출작업에 방해가된다. <br>  이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개변수가 너무 많아져서 <br>리팩터링 전보다 난해해질 수 있으므로, 그 수를 줄인다. |
| - 함수를 명령으로 바꾸기                                           | 위 기법들을 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 고려한다.                                                                                   |
| - 조건문 분해하기                                               | - 거대한 Switch문을 구성하는 case문마다 **함수 추출하기**를 적용해서 <br> 각 case의 본문을 함수 호출문 하나로 바꾼다.                                              |
| - 반복문 쪼개기                                                | - 반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. <br> - 이때, 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 이상의 작업이 <br> 섞여있는 것일 수 있기 때문에 작업을 분리한다.   |

## Long Parameter List (긴 매개변수 목록)

긴 매개변수의 장단점:

| 장점                        | 단점                    |
|---------------------------|-----------------------|
| 전역 데이터가 늘어나는 사태를 막을 수 있다. | 그 자체로 이해하기 어려울 때가 많다. |

| 리팩터링 기법           | 상황                                                                                                                        |
|-------------------|---------------------------------------------------------------------------------------------------------------------------|
| - 매개변수를 질의함수로 바꾸기 | 다른 매개변수에서 값을 얻어올 수 있는 매개변수를 제거할 수 있다.                                                                                     |
| - 객채 통째로 넘기기      | 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 <br> 원본 데이터 구조를 그대로 전달한다.                                                   |
| - 매개변수 객체 만들기     | 항상 함께 전달되는 매개변수들은 하나로 묶어버린다.                                                                                              |
| - 플래그 인수 제거하기     | 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 없애준다.                                                                                        |
| - 여러 함수를 클래스로 묶기  | - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용하는 경우,  <br> 공통 값들을 클래스의 필드로 정의하고, 클래스로 만들어준다. <br> - 함수형 프로그래밍의 경우, 일련의 부분 적용 함수들을 생성한다. |

## Global Data (전역 데이터)

전역데이터:

- 우리가 겪을 수 있는 악취 중 가장 지독한 축에 속한다.
- 코드 베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 메커니즘이 없다.
- 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵다
- 전역 변수 뿐만 아니라 클래스 변수와 싱글톤에도 같은 문제가 발생한다.
- 런타임에 값이 바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편이다.

| 리팩터링 기법  | 상황                                                                                                                                     |
|----------|----------------------------------------------------------------------------------------------------------------------------------------|
| 변수 캡슐화하기 | - 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고, <br> 접근을 통제할 수 있게된다. <br> - 접근자 함수들을 클래스나 모듈에 집어넣고 그안에서만 사용할 수 있도록 <br> 접근 범위를 최소로 줄인다. |                                                                                                                   |

## Mutable Data (가변 데이터)

가변 데이터의 위험성:

- 데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어진다.
- 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵다.

함수형 프로그래밍의 대처:

- 데이터는 절대 변경하지 않는다.
- 데이터를 변경하기 위해서는 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다.

> 다른 프로그래밍에서도, 불변성이 주는 장점을 살릴 수 있다.
>

| 리팩터링 기법                                  | 상황                                                                                     |
|------------------------------------------|----------------------------------------------------------------------------------------|
| 변수 캡슐화하기                                 | 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 <br> 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.                     |
| 변수 쪼개기                                   | 하나의 변수에 용도가 다른 값들을 저장하는라 값을 갱신하는 경우라면, <br> 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. |
| - 문장 슬라이드하기 <br> - 함수 추출하기               | 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.                                                      |
| 질의 함수와 변경 함수 분리하기                        | API 만들 때, 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.                                      |
| Setter 제거하기                              | Setter를 호출하는 클라이언트를 찾는 것만으로도 <br> 변수의 유효범위를 줄이는데 도움이 된다.                               |
| 파생 변수를 질의함수로 바꾸기                         | 값을 다른 곳에서 설정할 수 있는 가변데이터를 모두 질의 함수로 바꾸어준다.                                             |
| - 여러 함수를 클래스로 묶기 <br> - 여러 함수를 변환 함수로 묶기 | 변수를 갱신하는 코드들의 유효범위를 제한한다. 가변 데이터라 해도  <br> 변수의 유효 범위가 단 몇 줄뿐이라면 문제를 일으킬 일이 별로 없다.      |
| 참조를 값으로 바꾸기                              | 구조체처럼 내부 필드에 데이터를 담고있는 변수라면,  <br> 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체한다.                    |

## Divergent Change (뒤엉킨 변경) & Shotgun Surgery (산탄총 수술)

공통점:

| 구분    | 설명                                                                                                                     |
|-------|------------------------------------------------------------------------------------------------------------------------|
| 발생 원인 | - 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다.  <br> - 개발 초기에는 맥락 사이의 경계를 명확히 나누기가 어렵다 <br> - 소프트웨어 시스템의 기능이 변경되면 경계도 끊임없이 움직인다. |
| 해결방안  | 각 맥락을 명확히 구분한다.                                                                                                        |
| 효과    | 무언가를 수정할 때 해당 맥락의 코드만 이해해도 진행할 수 있다.                                                                                   |

차이점:

| 구분    | 뒤엉킨 변경                                | 산탄총 수술                              |
|-------|---------------------------------------|-------------------------------------|
| 발생 과정 | 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경된다 | 하나의 이유로 인해 여러가지 모듈이 여러 가지 방식으로 변경된다 |
| 해결 방안 | 서로 다른 맥락에서 이뤄지는 코드들은 독립된 모듈로 분리해야한다.  | 같은 맥락에서 이뤄지는 코드들은 하나의 모듈로 모아야한다.    |

<br>
뒤엉킨 변경:

| 리팩터링 기법  | 상황                                                                                                       |
|----------|----------------------------------------------------------------------------------------------------------|
| 단계 쪼개기   | 순차적으로 실행되는게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 <br> 특정 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.                        |
| 함수 추출하기  | 여러 맥락의 일에 관여하는 함수는 추출한다.                                                                                 |
| 함수 옮기기   | 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, <br> 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수를 모아서<br> 처리 과정을 맥락별로 구분한다. |
| 클래스 추출하기 | 모듈이 클래스라면 클래스 추출하기를 사용한다.                                                                                |

산탄총 수술:

| 리팩터링 기법                                                              | 상황                                                                                        |
|----------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| - 함수 옮기기  <br> - 필드 옮기기                                              | 함께 변경되는 대상들을 모두 한 모듈에 묶어둔다.                                                               |
| - 여러 함수를 클래스로 묶기                             <br> - 여러 함수를 변환 함수로 묶기 | - 비슷한 데이터를 다루는 함수가 많다면 클래스로 묶는다.        <br> - 데이터 구조를 변환하거나 보강하는 함수들은 변환함수로 묶는다.         |
| 단계 쪼개기                                                               | 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직을 전달할 수 있다면 <br> 단계를 쪼갠다.                                     |
| - 함수 인라인하기     <br> - 클래스 인라인하기                                      | - 어설프게 분리된 로직은 인라인 리팩터링으로 하나로 합친다.      <br> - 매서드나 클래스가 비대해지면 추출하기 리팩터링으로 더 좋은 형태로 분리한다. |

## Feature Envy (기능 편애)

| 구분    | 설명                                                      |
|-------|---------------------------------------------------------|
| 발생 원인 | 어떤 함수가 자기가 속한 모듈 영역보다 다른 모듈 영역에서의 <br> 상호작용이 많을 때 발생한다. |
| 해결 방안 | 함수를 데이터 근처로 옮겨준다.                                       |

<br>

**데이터와 이를 활용하는 동작이 함께 변경되지 않는 경우:**

- 예시
    - 전략 패턴
    - 방문자 패턴
    - 자기 위임
- 공통점
    - 뒤엉킨 변경을 해결할 때 활용하는 패턴들
    - 함께 변경할 대상을 한데 모으는 것
    - 같은 데이터를 다루는 코드를 한곳에서 변경할 수 있어 수정이 쉬워짐
        - 오버라이드해야할 소량의 동작 코드를 각각의 클래스로 격리해줌(전략 패턴과 방문자 패턴)

| 리팩터링 기법                                                 | 상황                                                                                   |
|---------------------------------------------------------|--------------------------------------------------------------------------------------|
| - 함수 추출하기                   <br> - 함수 옮기기               | 함수의 일부 기능에서만 기능을 편애하는 경우, <br> 독립 함수로 추출한 다음 원하는 모듈로 옮겨준다.                           |
| - 함수 옮기기                    <br> - 함수 추출하기<br> - 함수 옮기기 | 어디로 옮길지 명확하지 않을 시, 가장 많은 데이터를 포함한 모듈로 옮긴 후,<br> 함수를 여러 조각으로 나누고 다시 각각을 적합한 모듈로 옮겨준다. |

## Data Clumps (데이터 뭉치)

판별법:

- 값 하나를 삭제했을 때, 나머지 데이터만으로는 의미가 없는 데이터들

해결 방안:

- 데이터 뭉치를 클래스로 만들어준다

클래스로 만드는 이유:

- 기능 편애를 없애는 과정에서 새로 만든 클래스로 옮기면 좋을 동작을 찾아서 옮긴다
- 중복이 제거된다

| 리팩터링 기법                         | 상황                                       |
|---------------------------------|------------------------------------------|
| 클래스로 추출하기                       | 필드 형태의 데이터 뭉치를 찾아서 하나의 객체로 묶는다           |
| - 매개변수 객체 만들기 <br> - 객체 통째로 넘기기 | 메서드 시그니처에 있는 데이터 뭉치를 리팩터링하여 매개변수 수를 줄인다. |

## Primitive Obsession (기본형 집착)

자신에게 주어진 문제에 딱 맞는 기초 타입을 직접 정의하지 않는 경우:

- 화폐
- 좌표
- 구간 등

문자열화된 변수:

- 전화번호 등 단순히 문자 집합으로만 표현하기 아쉬운 변수

| 리팩터링 기법                                      | 상황                                                       |
|----------------------------------------------|----------------------------------------------------------|
| 기본형을 객체로 바꾸기                                 | 기본형을 자료형으로 바꿀 수 있다.                                      |
| - 타입 코드를 서브클래스로 바꾸기 <br> - 조건부 로직을 다형성으로 바꾸기 | 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰인 경우, <br> 리팩터링을 적용한다. |
| - 클래스 추출하기          <br> - 매개변수 객체 만들기       | 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치이므로,          <br> 리팩터링을 적용한다. |

## Repeated Switches (반복되는 Switch문)

Switch문이 문제가 되지 않는 이유:

- 과거와 비교해 지금은 다형성이 널리 자리 잡았다.
- 발전된 switch문을 제공하는 언어가 많아졌다.
    - 과거: 분기 조건에 몇 가지 기본형만 사용할 수 있었다.
    - 현재: 문자열 등 더 복잡한 타입까지 지원한다.

중복된 Switch문이 문제가 되는 이유:

- 조건절을 하나 추가할때 마다 해당하는 switch 문을 모두 찾아서 함께 수정해야한다.

| 리팩터링 기법           | 상황                                         |
|-------------------|--------------------------------------------|
| 조건부 로직을 다형성으로 바꾸기 | 같은 조건을 기준으로 나뉘는 switch문이 여러개라면, 다형성을 활용한다. |

## Loops (반복문)

반복문이 현재 문제가 되는 이유:

- 과거: 주요 언어들에 더 나은 대안이 없었다.
- 현재: 일급 함수를 지원하는 언어가 많아져 반복문을 파이프라인으로 바꿀 수 있다.

| 리팩터링 기법          | 상황                                                                     |
|------------------|------------------------------------------------------------------------|
| 반복문을 파이프라인으로 바꾸기 | filter나 map 같은 파이프 라인 연산을 사용하면 코드에서 각 원소들이 <br> 어떻게 처리되는지 쉽게 파악할 수 있다. |

## Lazy Element (성의없는 요소)

프로그램 요소:

- 함수 (메서드)
- 클래스
- 인터페이스 등

불필요한 프로그램 요소:

- 본문 코드를 그대로 쓴 것과 별 차이 없는 함수
- 실질적으로 메서드가 하나뿐인 클래스

불필요한 프로그램 요소가 발생한 이유:

- 오버엔지니어링
- 리팩터링으로 인한 역할 축소

| 리팩터링 기법                      | 상황                        |
|------------------------------|---------------------------|
| - 함수 인라인하기  <br> - 클래스 인라인하기 | 구조적으로 불필요한 프로그램 요소를 제거한다. |
| 계층 합치기                       | 상속을 사용한 경우 리팩터링한다.        |

## Speculative Generality (추측성 일반화)

발생 원인:

- 나중에 필요할 거라고 판단한다
- 당장은 필요없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔다

결과:

- 이해나 관리하기 어렵다

| 리팩터링 기법                      | 상황                                                            |
|------------------------------|---------------------------------------------------------------|
| 계층 합치기                       | 하는 일이 거의 없는 추상 클래스를 제거한다                                      |
| - 함수 인라인하기  <br> - 클래스 인라인하기 | 쓸데없이 위임하는 코드를 삭제한다.                                           |
| 함수 선언 바꾸기                    | 본문에서 사용되지 않는 매개변수를 없앤다.                                       |
| 죽은 코드 제거하기                   | 테스트 코드 말고 사용하는 곳이 없는 함수나 클래스의 경우, <br> 테스트 케이스부터 삭제한 뒤에 제거한다. |

## Temporary Field (임시필드)

임시 필드:

- 특정 상황에서만 값이 설정되는 필드

문제:

- 객체를 가져올때는 모든 필드가 채워져있으리라 기대한다.
- 그래서 임시 필드를 갖도록 작성한 코드를 이해하기 어렵다.
- 사용자가 해당 필드의 의도를 파악하느라 머리를 싸매게 된다.

| 리팩터링 기법     | 상황                                                                            |
|-------------|-------------------------------------------------------------------------------|
| 클래스 추출하기    | 임시 필드들을 별도의 클래스로 분리한다.                                                        |
| 함수 옮기기      | 임시 필드들과 관련된 코드를 새 클래스로 옮긴다.                                                   |
| 특이 케이스 추가하기 | 임시 필드들이 유효한지 확인한 후 동작하는 조건부 로직의 경우, <br> 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거한다. |

## Message Chains (메시지 체인)

메시지 체인:

- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 방금 얻은 객체에 또 다른 객체를 요청하는 행위
- 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드

문제:

- 클라이언트가 객체 내비게이션 구조에 종속되었음
- 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야함

| 리팩터링 기법                 | 상황                                                                                                    |
|-------------------------|-------------------------------------------------------------------------------------------------------|
| 위임 숨기기                  | - 메시지 체인의 다양한 연결점에 적용할 수 있다.    <br> - 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그러다보면 중간 객체들이 모두 중개자가 될 수 있다. |
| - 함수 추출하기 <br> - 함수 옮기기 | - 최종 결과 객체를 사용하는 코드 일부를 따로 빼낸다.                                                                       |

- 해당 함수를 옮겨서 체인을 숨길 수 있는 지 살펴본다.
- 체인 구성하는 객체 중 특정 하나를 사용하는 클라이언트가 그 이후의 객체들도 사용하길 바라는 경우가 많다면, 이 요구를 처리해줄 메서드를 추가한다. |

## Middle Man (중개자)

캡슐화:

- 외부로부터 세부 사항을 숨겨줌
- 객체의 대표적인 기능 중 하나
- 캡슐화 과정에서 위임이 자주 활용된다.

중개자:

- 클래스의 메소드의 절반이 다른 객체에게 위임하고 있는 구조

| 리팩터링 기법  | 상황                                                                                |
|----------|-----------------------------------------------------------------------------------|
| 중개자 제거하기 | 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있는 경우, <br> 리팩터링하여 실제로 일을 하는 객체와 직접 소통하게 한다. |
| 함수 인라인하기 | 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자                                         |

## Insider Trading (내부자 거래)

내부자 거래:

- 모듈 사이의 데이터 거래가 많다
- 결합도가 높다
- 데이터 거래의 양을 최소로 줄여야한다.

| 리팩터링 기법                                  | 상황                                                                                     |
|------------------------------------------|----------------------------------------------------------------------------------------|
| - 함수 옮기기 <br> - 필드 옮기기                   | 모듈 사이의 결합도를 낮추기 위해 리팩터링한다.                                                             |
| 위임 숨기기                                   | - 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제 3의 모듈은 새로 만든다. <br> - 다른 모듈이 중간자 역할을 하게 만든다. |
| - 서브클래스를 위임으로 바꾸기 <br> - 슈퍼클래스를 위임으로 바꾸기 | 상속 구조에서 부모와 자식 클래스 간의 결합이 많아진다면, 리팩터링하여 분리한다.                                          |

## Large Class (거대한 클래스)

거대한 클래스:

- 공통점: 중복과 혼동을 일으킬 여지가 크다.
- 필드가 너무 많은 클래스
    - 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어난다.
    - 클래스가 항시 모든 필드를 사용하지 않을 때는 앞서 언급한 추출 기법들을 여러 차례 수행한다.
- 코드량이 너무 많은 클래스
    - 클래스 안에서 자체적으로 중복을 제거한다.
    - 클라이언트들이 해당 클래스를 어떻게 이용하는지 패턴을 파악하여 클래스를 쪼갠다.

| 리팩터링 기법                                                                                 | 상황                                                                                        |
|-----------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| 클래스 추출하기                                                                                | - 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 따로 묶는다. <br> - 더 일반적으로는 한 클래스 안에서 접두어나 접미어가 같은 필드들을 추출한다. |
| - 슈퍼 클래스 추출하기                                <br> - 타입 코드를 서브클래스로 바꾸기                   | - 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면,   <br> 클래스 추출보다는 다른 리팩터링을 적용한다.                     |
| - 클래스 추출하기                                   <br> - 슈퍼 클래스 추출하기<br> - 타입 코드를 서브클래스로 바꾸기 | - 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용한다면,<br>   리팩터링을 활용하여 여러 클래스로 분리한다.                      |

## Alternative Classes With Different Interfaces (서로 다른 인터페이스의 대안 클래스들)

클래스 사용의 장점:

- 인터페이스가 같다면, 필요에 따라 언제든 다른 클래스로 교체할 수 있다.

| 리팩터링 기법     | 상황                                                                       |
|-------------|--------------------------------------------------------------------------|
| 함수 선언 바꾸기   | 교체하려는 클래스들의 메서드 시그니처를 일치시킨다.                                             |
| 함수 옮기기      | 함수 선언 바꾸기만으로 부족한 경우, 인터페이스가 같아질 때까지        <br> 필요한 동작들을 클래스 안으로 밀어 넣는다. |
| 슈퍼 클래스 추출하기 | 대안 클래스들 사이에 중복 코드가 생기면 슈퍼 클래스를 추출할 지 고민한다.                               |

## Data Class (데이터 클래스)

데이터 클래스:

- 구성 요소
    - 데이터 필드
    - getter
    - setter
- 문제점: 다른 클래스가 멋대로 변경할 여지가 많다.
- 데이터 클래스 자체가 필요한 동작이 엉뚱한 곳에 정의돼있다는 신호일 수 있다.
    - 해당 경우, 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.

| 리팩터링 기법                   | 상황                                        |
|---------------------------|-------------------------------------------|
| 레코드 캡슐화하기                 | public 필드가 있다면 리팩터링을 진행한다.                |
| Setter 제거하기               | 변경하면 안되는 필드는 리팩터링을 적용하여 접근을 원천 봉쇄한다.      |
| - 함수 옮기기   <br> - 함수 추출하기 | - 데이터 클래스의 getter와 setter를 이용하는 메서드를 찾아서, |

데이터 클래스로 옮긴다.

- 메서드를 통째로 옮기기 어렵다면 리팩터링해서 옮길 수 있는 부분만
  별도 메서드로 뽑아낸다. |
  | 단계 쪼개기 | 단계 쪼개개의 결과로 나온 중간 데이터 구조의 경우,
  실제로 활용되는 모습 상으로는 수정될 가능성이 없으므로(불변)
  예외적으로 캡슐화할 필요가 없다. |

## Refused Bequest (상속 포기)

부모 클래스로부터 물려받는 메소드와 데이터 중 일부만 필요한 경우:

- 과거
    - 원인: 계층 구조를 잘못 설계해서
    - 해결방안: 리팩터링을 진행하여 부모클래스에는 공통된 부분만 남긴다.
- 현재
    - 원인: 서브 클래스가 부모의 동작은 필요로 하지만 인터페이스를 따르고 싶지 않아서
    - 해결 방안: 리팩터링하여 상속 매커니즘을 벗어난다.

| 리팩터링 기법                                      | 상황                                                                  |
|----------------------------------------------|---------------------------------------------------------------------|
| - 메서드 내리기             <br> - 필드 내리기          | 같은 계층에 서브클래스를 만들고, 리팩터링하여 물려받지 않을 부모 코드를 <br> 모조리 새로 만든 서브클래스로 넘긴다. |
| - 서브클래스를 위임으로 바꾸기     <br> - 슈퍼클래스를 위임으로 바꾸기 | 재활용하기위해 필요한 동작을 리팩터링한 후, 위임한다.                                      |

## Comments (주석)

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
>

주석:

- 올바른 주석은 코드에 향기를 입힌다.
- 그러나 주석을 탈취제처럼 사용하면 문제가 생긴다.
- 뭘 할지 모르거나, 확실하지 않다면 코드를 지금처럼 작성한 이유를 설명하는 용도로 주석을 남긴다.

| 리팩터링 기법  | 상황                                                           |
|----------|--------------------------------------------------------------|
| 함수 추출하기  | 특정 코드 블록이 하는 일에 주석을 남기고 싶은 경우 적용한다.                          |
| 함수 선언하기  | 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면      <br> 리팩터링하여 함수 이름을 변경한다. |
| 어서션 추가하기 | 시스템이 동작하기 위한 선생조건을 명시하고 싶다면 적용한다.                            |
