# **Chapter9. 데이터 조직화**

---

하나의 값이 여러 목적으로 사용된다면 혼란과 버그를 낳으므로, 용도별로 분리해야한다.

- 변수쪼개기 (+ 변수 이름 바꾸기)

변수 자체를 완전히 없애는 게 가장 좋은 해법일 때도 있다.

- 파생 변수를 질의 함수로 바꾸기

참조인지 값인지 헷갈리는 경우, 둘 사이를 전환한다.

- 참조를 값으로 바꾸기
- 값을 참조로 바꾸기

코드에 의미를 알기 어려운 리터럴이 보이면 명확하게 바꿔준다.

- 매직 리터럴 바꾸기

<br>

## 9.1 변수 쪼개기

### 변수에 값을 여러번 대입할 수 밖에 없는 경우
- 루프 변수 (반복문을 한 번 돌 때마다 값 변경)
- 수집 변수 (메서드가 동작하는 중간 값 저장)

### 변수에 값을 단 한번만 대입해야하는 경우
- 긴 코드의 결과를 저장했다가 나중에 참조하는 경우
- 대입이 두 번 이상 이뤄지는 경우
    - 여러가지 역할을 수행한다는 신호
    - 역할별로 분리

| 배경 | 기준:  변수의 역할이 둘 이상인 경우                                                                                                                                                                                                                                                                                        |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다. <br> 2. 이때, 가능하면 불변으로 선언한다. <br> 3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다. <br> 4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다. <br> 5. 테스트한다. <br> 6. 반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.                             |
| 예시 | 1. 음식이 다른 지역으로 전파된 거리를 구하는 코드                                                                                                                                                                                                                                                     <br> 2. 입력 매개 변수의 값을 수정할 때 |

<br>

## 9.2 필드 이름 바꾸기

### 데이터 구조
- 프로그램을 이해하는 데 큰 역할을 한다.
- 그렇기에 프로그램 곳곳에서 쓰이는 레코드의 필드 이름은 더욱 중요하다
- 데이터 구조는 중요한 만큼 반드시 깔끔하게 관리해야한다.
    - 개발을 진행할 수록 깊어진 이해를 바탕으로 더 적합한 이름이 보인다면 이를 즉시 반영해야한다.

| 배경 | 기준: 데이터에 대해 깊어진 이해를 프로그램에 반영하고 싶은 경우                                                                                                                                                                                                                              |
|----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이 후 단계는 필요없다. <br> 2. 레코드가 캡슐화 되지 않았다면 우선 레코드를 캡슐화한다. <br> 3. 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다. <br> 4. 테스트한다. <br> 5. 생성자의 매개변수 중 필드와 이름이 겹치는게 있다면 함수 선언 바꾸기로 변경한다. <br> 6. 접근자들의 이름도 바꾸어준다. |
| 예시 | 1. Organization의 “name”필드를 “title”로 수정하기                                                                                                                                                                                                                          |

<br>

## 9.3 파생 변수를 질의 함수로 바꾸기

### 가변 데이터
- 소프트웨어에 문제를 일으키는 가장 큰 골칫거리 중 하나
- 가변 데이터의 유효 범위를 가능한 좁혀야한다

### 해결 방법
- 값을 쉽게 계산해낼 수 있는 변수들은 모두 제거하고 함수를 사용한다.
    - 코드 자체가 데이터의 의미를 더 분명히 드러낸다
    - 변경된 값을 깜빡하고 결과 변수에 반영하지 않는 실수를 막아준다.
- 예외
    - 피연산자 데이터가 불변인 경우
        - 계산 결과도 일정하기 때문에 문제를 해결하기 쉽다.

### 변형 연산 (새로운 데이터 구조를 생성)
1. 값 객체
    - 데이터 구조를 감싸며 그 데이터에 기초하여 계산한 결과를 속성으로 제공하는 객체
2. Repository
    - 데이터 구조를 받아 다른 데이터 구조로 변환해 반환하는 함수
    - 소스 데이터가 가변이고, 파생 데이터 구조의 수명을 관리해야하는 상황에서는 객체를 사용한다.

| 배경 | 기준:                                                                                                                                                                                                                                                                          |
|----|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다. <br> 2. 해당 변수의 값을 계산해주는 함수를 만든다. <br> 3. 해당 변수가 사용되는 모든 곳에서 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다. <br> 4. 테스트한다. <br> 5. 변수를 읽는 코드를 모두 함수 호출로 대체한다. <br> 6. 테스트한다. <br> 7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다. |
| 예시 | 1. adjustment 적용 과정에서 누적 값 production을 갱신하는 코드 <br> 2. 소스가 둘 이상일 때                                                                                                                                                                                                           |

<br>

## 9.4 참조를 값으로 바꾸기

### 참조와 값
- 객체(데이터 구조)를 다른 객체(데이터 구조)에 중첩하면 내부 객체를 **참조 혹은 값**으로 취급 가능
- 차이
    - 내부 객체의 속성을 갱신하는 방식
        - 참조: 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신
        - 값: 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체

### 값 객체
- 필드를 값으로 다룬다면, 내부 객체의 클래스를 수정하여 값객체로 만들 수 있다.
- 불변이기 때문에 값을 복제해 사용하더라도 서로간의 참조를 관리하지 않아도 된다.
- 이러한 이유로, 분산 시스템과 동시성 시스템에서 유용하다.

| 배경 | 기준: 필드의 값을 불변으로 관리하고 싶은 경우                                                                                 |
|----|------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다. <br> 2. 각각의 세터를 하나씩 제거한다. <br> 3. 이 값 객체의 필드들을 사용하는 동등성 비교 메서드를 만든다. |
| 예시 | 1. TelephoneNumber 클래스를 값 객체로 만들기                                                                          |

<br>

## 9.5 값을 참조로 바꾸기

### 값과 참조 어느 것이라도 상관 없는 경우
- 특정 객체를 여러 객체에서 공유하는 경우
    - 데이터가 갱신될 일이 없다면 어느 방식이든 상관없다.
    - 다른 성능 이슈와 마찬가지로, 복사본이 많이 생겨서 메모리가 부족한 경우는 매우 드뭄

### 반드시 참조로 관리해야하는 경우
- 공유 객체의 값이 변경됐을 때, 이를 관련 객체 모두가 알아야하는 경우
    - 모든 복제본을 찾아서 빠짐없이 갱신해야함
    - 하나의 복제본이라도 누락된 경우 데이터 일관성이 깨짐

### 저장소 (Repository)
- 값을 참조로 바꾸면 엔티티 하나당 객체도 단 하나만 존재
- 이런 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 일종의 저장소 필요
    - 각 엔티티를 표현하는 객체를 한번만 만든다
    - 객체가 필요한 경우, 이 저장소로부터 얻어 쓴다.

| 배경 | 기준: 데이터를 갱신할 때, 일관성을 지켜야하는 경우                                                                                                                                |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다 <br> 2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다. <br> 3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다. 하나 수정할 때마다 테스트한다. |
| 예시 | 1. Customer 클래스를 값 객체에서 entity로 만들기                                                                                                                          |

<br>

## 9.6 매직 리터럴 바꾸기

### 매직 리터럴
- 소스 코드에 등장하는 일반적인 리터럴 값
- 숫자(혹은 리터럴) 자체로는 의미를 명확히 알려주지 못하므로 코드를 읽는 사람이 이해하기 어렵다
- 상수로 정의하고 리터럴 대신 상수를 사용한다.
- 상수화 하지 않는 경우
    - 의미 전달면에서 값을 바로 쓰는 것보다 나을 게 없는 경우
    - 함수 하나에서만 쓰이고, 함수가 맥락 정보를 충분히 제공하는 경우

| 배경 | 기준: 값 자체가 뜻을 명확히 알려주지 못하는 경우                                                                                                       |
|----|------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 상수를 선언하고 매직 리터럴을 대입한다. <br> 2. 해당 리터럴이 사용되는 곳을 모두 찾는다. <br> 3. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트한다. |
| 예시 | _                                                                                                                                  |
