# Chapter12. 상속 다루기

---

### 특정 기능을 상속 계층구조의 위나 아래로 옮겨야 하는 상황에 적용할 수 있다.

- 메서드 올리기 / 내리기
- 필드 올리기 / 내리기
- 생성자 본문 올리기

### 계층 사이에 클래스를 추가하거나 제거할 때 적용할 수 있다.

- 슈퍼클래스 추출하기
- 서브클래스 제거하기
- 계층 합치기

### 필드 값에 따라 동작이 달라지는 코드를 서브클래스로 대체할 때 적용할 수 있다.

- 타입 코드를 서브클래스로 바꾸기

### 상속이 잘못된 곳에서 사용되거나 나중에 환경이 변해 문제가 생기는 경우 상속을 위임으로 바꿔준다.

- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

<br>

## 12.1 메서드 올리기

### 적용 상황

- 가장 쉬운 경우
    - 메소드들의 본문 코드가 똑같은 경우
- 선행 단계를 거쳐야하는 경우
    - 실질적으로 하는 일은 같지만 코드가 다른 경우
    - 서로 다른 두 클래스의 두 메서드를 각각 매개변수화 하기
- 가장 복잡한 경우
    - 메서드에서 참조하는 필드들이 서브클래스에만 있는 경우
    - 필드를 슈퍼클래스로 올린 후, 메서드를 올려야한다.
- 전체 흐름은 비슷하지만 세부 내용이 다른 경우
    - 템플릿 메서드 패턴 고려

| 배경 | 기준:  중복 코드를 찾은 경우                                                                                                                                                                                                                                                                                                                           |
|----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 똑같이 동작하는 메서드인지 면밀히 살펴본다. <br> 2. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는 지 확인한다. <br> 3. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다. <br> 4. 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣는다. <br> 5. 정적 검사를 수행한다. <br> 6. 서브 클래스 중 하나의 메서드를 제거한다. <br> 7. 테스트한다. <br> 8. 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다. |
| 예시 | 1. 서브 클래스에서 같은 일을 수행하는 메서드                                                                                                                                                                                                                                                                                                                  |

<br>

## 12.2 필드 올리기

### 상속 구조의 중복

- 발생 원인
    - 서브클래스들이 독립적으로 개발된 경우
    - 뒤늦게 하나의 계층 구조로 리팩터링된 경우
- 리팩터링 효과
    - 데이터 중복선언 제거 가능
    - 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 이동 가능

| 배경 | 기준:  필드 이용 분석 후, 비슷한 방식으로 쓰인다고 판단되는 경우                                                                                                                            |
|----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다. <br> 2. 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다. <br> 3. 슈퍼클래스에 새로운 필드를 생성한다. <br> 4. 서브클래스의 필드들을 제거한다. <br> 5. 테스트한다. |
| 예시 | _                                                                                                                                                                 |

<br>

## 12.3 생성자 본문 올리기

### 생성자의 호출 순서 제약

- 부모 → 자식 순으로 호출된다.
- Java 등에서는 `super()` 호출은 반드시 첫줄이어야한다.
- 해당 리팩터링이 간단히 끝날 것 같지 않다면 생성자를 팩터리 함수로 바꾸기를 고려해본다.

| 배경 | 기준:  서브클래스의 생성자에 중복이 발견된 경우                                                                                                                                                                                                                                                          |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다. <br> 2. 문장 슬라이드하기로 공통 문장 모두를 super() 호출 직후로 옮긴다. <br> 3. 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넨다. <br> 4. 테스트한다. <br> 5. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다. |
| 예시 | 1. 서브 클래스 생성자의 공통된 대입 부분 <br> 2. 공통 코드가 나중에 올 때                                                                                                                                                                                                                                      |

<br>

## 12.4 메서드 내리기

### 적용 상황

- 호출자가 해당 기능이 어떤 서브클래스에 있는지 알고 있는 경우
    - 특정 서브클래스에만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스에 추가
- 호출자가 모르는 경우
    - 슈퍼클래스에 조건문으로 구현된 로직을 다형성으로 대체

| 배경 | 기준:  특정 서브 클래스만 관련된 메서드인 경우                                                                                                   |
|----|-------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 대상 메서드를 모든 서브클래스에 복사한다. <br> 2. 슈퍼클래스에서 그 메서드를 제거한다. <br> 3. 테스트한다. <br> 4. 이 메서드를 사용하지 않는 모든 서브클래스에서 제거한다. <br> 5. 테스트한다. |
| 예시 | _                                                                                                                             |

<br>

## 12.5 필드 내리기

| 배경 | 기준:  특정 서브클래스에서만 사용하는 필드인 경우                                                                                               |
|----|----------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 대상 필드를 모든 서브클래스에 정의한다. <br> 2. 슈퍼클래스에서 그 필드를 제거한다. <br> 3. 테스트한다. <br> 4. 이 필드를 사용하지 않는 모든 서브클래스에서 제거한다. <br> 5. 테스트한다. |
| 예시 | _                                                                                                                          |

<br>

## 12.6 타입 코드를 서브클래스로 바꾸기

### 타입 코드

- 비슷한 대상들을 특정 특성에 따라 구분해야하는 경우
- 프로그래밍 언어에 따라 열거형, 심볼, 문자열, 숫자등으로 표현

### 타입 코드를 서브클래스로 바꿔야 하는 경우

- 조건에 따라 다르게 동작하도록 해주는 다형성 제공해야하는 경우
- 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있는 경우
- 관계를 명확히 드러내야하는 경우

### 적용 대상에 따른 구분

- 직접 상속
    - `type` 필드를 가지고 있는 원래의 클래스가 **바로 슈퍼클래스가 되는 경우**
    - 선택 로직의 위치: 생성자를 팩터리 함수로 바꾸기를 적용하고 선택 로직을 팩터리에 넣는다.
- 간접 상속
    - 실제 동작하는 클래스와는 별개로, `type` 필드를 따로 관리하는 **중간 데이터 구조**가 있는 경우
    - 선택로직의 위치: 생성자에 선택 로직을 둔다.

| 배경 | 기준:  조건에 따라 다르게 동작하도록 해주는 다형성 제공해야하거나, 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있는 경우                                                                                                                                                                                                                                                                                              |
|----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 타입 코드 필드를 자가 캡슐화한다. <br> 2. 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만든다. 타입코드 게터 메서드를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하게 한다. <br> 3. 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 선택 로직을 만든다. <br> 4. 테스트한다. <br> 5. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복한다. 클래스 하나가 완성될 때마다 테스트한다. <br> 6. 타입 코드 필드를 제거한다. <br> 7. 테스트한다. <br> 8. 타입 코드 접근자를 이용하는 메서드 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기를 적용한다. |
| 예시 | 1. 직접 상속할 때 <br> 2. 간접 상속할 때                                                                                                                                                                                                                                                                                                                                               |

<br>

## 12.7 서브클래스 제거하기

| 배경 | 기준:  더 이상 쓰이지 않는 서브클래스인 경우                                                                                                                                                                                                                                |
|----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 서브클래스의 생성자를 팩터리 함수로 바꾼다. <br> 2. 서브클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 차례로 적용하여 슈퍼클래스로 옮긴다. 하나 변경할 때마다 테스트한다. <br> 3. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만든다. <br> 4. 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정한다. <br> 5. 서브클래스를 지운다. <br> 6. 테스트한다. |
| 예시 | 1. 성별 서브 클래스 제거                                                                                                                                                                                                                                           |

<br>

## 12.8 슈퍼클래스 추출하기

### 상속 구조

- 적용 방법
    - 현실 세계의 분류 체계: 상속을 적용하는 데 힌트로 사용 가능
    - 프로그램이 성장해 나가면서 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행
- 대안
    - 클래스 추출하기
- 선택 기준
    - 중복 동작을 상속으로 해결하느냐 위임으로 해결하느냐
    - 슈퍼 클래스를 추출하는 게 더 간단한 경우가 많으니 해당 리팩터링을 먼저 시도한다.
    - 위임이 필요해진 경우 슈퍼클래스를 위임으로 바꾸기를 적용한다.

| 배경 | 기준:  중복 동작을 상속으로 해결해야하는 경우                                                                                                                                                                                                                                    |
|----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 빈 슈퍼클래스를 만든다. 원래의 클래스들이 새 클래스를 상속하도록 한다. <br> 2. 테스트한다. <br> 3. 생성자 본문 올리기, 메서드 올리기, 필드 올리기를 차례로 적용하여 공통 원소를 슈퍼클래스로 옮긴다. <br> 4. 서브클래스에 남은 메서드들을 검토한다. 공통되는 부분이 있다면 함수로 추출한 다음 메서드 올리기를 적용한다. <br> 5. 원래 클래스들을 사용하는 코드를 검토하여, 슈퍼클래스의 인터페이스를 사용하게 할지 고민해본다. |
| 예시 | 1. 두 클래스의 공통된 기능                                                                                                                                                                                                                                              |

<br>

## 12.9 계층 합치기

| 배경 | 기준:  계층 구조가 진화하면서 서브클래스와 슈퍼클래스가 너무 비슷해져서 더는 독립적으로 존재해야할 이유가 사라지는 경우                                                                                                               |
|----|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 두 클래스 중 제거할 것을 고른다. <br> 2. 필드 올리기와 메서드 올리기 혹은 필드 내리기와 메서드 내리기를 적용하여 모든 요소를 하나의 클래스로 옮긴다. <br> 3. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다. <br> 4. 빈 클래스를 제거한다. <br> 5. 테스트한다. |
| 예시 | _                                                                                                                                                                                 |

<br>

## 12.10 서브클래스를 위임으로 바꾸기

### 상속

- 장점
    - 특성에 따라 동작이 달라지는 객체를 표현하기 자연스럽다
    - 슈퍼클래스: 공통 데이터와 동작
    - 서브클래스:특성에 맞게 기능 추가 및 오버라이드
- 단점
    - 여러 개의 기준으로 분류되더라도 그 중 하나의 기준만을 선택할 수 밖에 없다.
    - 클래스들 간의 관계를 아주 긴밀하게 결합한다.

### 위임

- 상속의 두 단점 모두 해결 가능
    - 다양한 클래스에서 서로 다른 이유로 위임 가능
    - 상속보다 결합도가 훨씬 약함
        - 객체 사이의 일반적인 관계
        - 상호작용에 필요한 인터페이스를 명확히 정의 가능
- “상속보다는 컴포지션”
    - 상속을 쓰지말라는 게 아니라, 광요하는 데 따른 반작용으로 나온 것
    - 상속으로 접근한 다음, 문제가 생기면 위임으로 변경
        - 서브클래스는 언제든 위임으로 바꿀 수 있음
        - 서브클래스를 상태 패턴이나 전략패턴으로 대체
            - 해당 패턴들은 호스트 위임 방식으로 계층구조를 분리

| 배경 | 기준:  상속구조에서 문제가 생기기 시작하는 경우                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1. 생성자를 호출하는 곳이 많다면 생성자를 팩터리 함수로 바꾼다. <br> 2. 위임으로 활용할 빈 클래스를 만든다. 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통은 슈퍼클래스를 가리키는 역참조도 필요한다. <br> 3. 위임을 저장할 필드를 슈퍼클래스에 추가한다. <br> 4. 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다. <br> 5. 서브클래스의 메서드 중 위임 클래스로 이동할 것을 고른다. <br> 6. 함수 옮기기를 적용해 위임 클래스로 옮긴다. 원래 메서드에서 위임하는 코드는 지우지 않는다. <br> 7. 서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다. 이 때 위임이 존재하는지를 검사하는 보호코드로 감싸야한다. 호출하는 외부 코드가 없다면 원래 메서드는 죽은 코드가 되므로 제거한다. <br> 8. 테스트한다. <br> 9. 서브클래스의 모든 메서드가 옮겨질때까지 반복한다. <br> 10. 서브클래스의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정한다. <br> 11. 테스트한다. <br> 12. 서브클래스를 삭제한다. |
| 예시 | 1. 서브클래스가 하나일 때 <br> 2. 서브클래스가 여러 개일때                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |

<br>

## 12.11 슈퍼클래스를 위임으로 바꾸기

### 리스코프 치환 원칙

- 제대로 된 상속이라면 해당 원칙을 준수해야한다.
- 서브클래스가 슈퍼클래스의 모든 기능을 사용
- 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야한다.
- 즉, 슈퍼클래스가 사용되는 모든 곳에서 서브클래스의 인스턴스를 대신 사용해도 이상없이 동작해야한다.

### 슈퍼클래스를 위임으로 바꾸는 경우

- 타입-인스턴스 동형이의어
    - 의미: 도메인 모델링 시, 동일한 단어가 타입과 인스턴스 두 가지 의미로 혼용되는 것
    - 문제점: 모델의 명확성을 해쳐, 잘못된 책임 분배나 클래스 설계로 이어질 수 있다.
    - 해결 방안: 상속 대신 위임을 사용하고, 명확한 명명으로 구분한다.
- 슈퍼/서브클래스가 강하게 결합된 관계
    - 문제점: 슈퍼클래스를 수정하면 서브클래스가 망가지기 쉽다.
    - 해결 방안: 서브클래스 모델링 방식 모델링이 합리적이어도 위임을 적용해야한다.
- 단점:
    - 호스트의 함수 모두를 전달 함수로 만들어야 한다.
    - 그러나 형태가 아주 단순하기 때문에 문제가 생길 가능성이 적다.

| 배경 | 기준:  슈퍼클래스의 기능들이 서브클래스에는 어울리지 않는 경우                                                                                                                                                                                |
|----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 절차 | 1.  슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다. 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다. <br> 2. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다. 서로 관련된 함수끼리 그룹으로 묶어 진행하며, 그룹을 하나씩 만들 때마다 테스트한다. <br> 3. 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드 되었다면 상속 관계를 끊는다. |
| 예시 | 1. 카탈로그 아이템 상속 관계 끊기                                                                                                                                                                                               |
