# Chapter1. 리팩터링: 첫 번째 예시

***

## 0단계: 요구 사항 분석 및 코드 작성

### 기능 요구 사항 (공연료 청구서 출력)

- 공연 요청이 들어오면 연극의 장르와 관객 규모를 기초로 비용을 책정한다.
- 현재 이 극단은 두 가지 장르, 비극(tragedy) 와 희극(comedy) 만 공연한다.
- 그리고 공연료와 별개로 포인트(volume credit) 를 지급해서 다음번 의뢰 시 공연료를 할인받을 수 있다.
- 극단은 공연할 연극 정보를 `plays.json`과 같은 형태로 저장한다.
- 극단은 공연료 청구서에 들어갈 데이터를 `invoice.json`과 같은 형태로 저장한다.
- 결과는 다음과 같이 출력된다.

  ```text
    청구 내역 (고객명: BigCo)
     Hamlet: $650.00원 (55석)
     As You Like It: $580.00원 (35석)
     Othello: $500.00원 (40석)
    총액: $1,730.00원
    적립 포인트: 47점
  ```

### 프로그래밍 요구 사항

자바스크립트와 자바간의 패러다임 차이를 해결하기 위해 다음 사항을 추가한 상태로 시작한다.

1. 코드를 실행하기 위한 `application` 클래스 추가
2. 기존 `statement()`를 `Statement` 클래스에 static 메서드로 선언
3. json 파일을 로드해 자바 객체로 변환하기 위한 `loadResource()` 메서드 구현
    - json 데이터를 저장할 `record` 추가한다
    - 클래스 로더를 통해 `resourcePath`로 지정된 json 파일을 **InputStream** 형태로 가져온다.
    - **InputStream**으로부터 읽은 JSON 데이터를, `Jackson` 라이브러리를 통해 `typeRef`에서 명시한 타입(`T`)으로 변환한다.

### 만약  청구 내역을 HTML로 출력하는 기능이 추가되어야 한다면?

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면,
> 먼저 기능을 추가하기 쉬운 형태로 리팩토링하고 나서 원하는 기능을 추가한다.

<br/>

## 1단계: 테스트 코드 만들기

> 리팩토링하기 전에 제대로 된 테스트를 마련한다.
> 테스트는 반드시 자가진단하도록 한다.

statement() 함수의 테스트는 어떻게 구현하면 될까?

- 이 함수가 문자열을 반환하므로 다양한 장르와 공연들로 구성된 형태를 몇 개 작성해서 문자열 형태로 준비해둔다.

<br/>

## 2단계: 함수 쪼개기

### amountFor(aPerformance) 추출하기

> 리팩토링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

- 함수 추출하기
    - 코드가 하는 일을 설명하는 이름을 지어줌으로써, 코드를 분석하며 파악한 정보를 코드에 반영한다.
- 변수 네이밍 변경하기
    - 변수의 역할을 쉽게 알 수 있다.
- 파라미터 네이밍 변경하기
    - 동적 타입 언어를 사용할 때 타입이 드러나게 작성하면 도움된다.
    - 매개변수의 역할이 뚜렷하지 않을 때는 부정 관사(a/an)을 붙인다.

> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다.
> 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

### Play 변수 제거하기

- 임시 변수를 질의 함수로 바꾸기
- 변수 인라인하기
- 함수 선언 바꾸기
    - playFor() 메서드를 사용하도록 amountFor() 수정
    - play 매개변수 삭제하기
- 변수 인라인하기

### 적립 포인트 계산 코드 추출하기

- 함수 추출하기
- 파라미터 네이밍 변경하기
- 변수 네이밍 변경하기

### format 변수 제거하기

- 함수 변수를 일반함수로 변경
- 함수 선언 바꾸기
- 단위 변환 로직 (나눗셈)을 함수 내로 위치 이동

### volumeCredits 변수 제거하기

- 반복문 쪼개기
- 문장 슬라이드하기
- 임시 변수를 질의 함수로 바꾸기
    - 함수 추출하기
    - 변수 인라인하기

### totalAmount 제거하기

- 반복문 쪼개기
- 문장 슬라이드하기
- 임시 변수를 질의 함수로 바꾸기
    - 함수 추출하기
    - 변수 인라인하기

<br/>

## 3단계: 단계 쪼개기

- 함수 추출하기
- 중간 데이터 구조 객체 생성
- 중간 데이터 구조 인수 전달
- 기존 인수들의 데이터를 중간 데이터 구조로 이동시키기
    - 고객 정보 이동
    - 공연 정보 이동
- 기존 인수 제거
- 얕은 복사를 위한 객체 추가
- 함수 옮기기
- 함수 호출을 중간 데이터 사용으로 변경
- 반복문을 파이프라인으로 바꾸기

### 계산 단계와 포맷팅 단계 분리 결과

| 단계  | 담당 클래스                           |
|-----|----------------------------------|
| 계산  | StatementData, EnrichPerformance |
| 포매팅 | Statement                        |

- 코드량 증가
- 로직을 구성하는 요소 각각이 더 부각
- 계산하는 부분과 출력을 다루는 부분 분리 (모듈화)
- 계산 코드 중복없이 htmlRender 메서드 구현 가능

> 캠핑자들에게는 "도착했을 때보다 깔끔하게 정돈하고 떠난다"는 규칙이 있다.
> 프로그래밍도 마찬가지다.
> 항시 코드베이스를 작업 시작 전보다 건강하게(healthy) 만들어놓고 떠나야한다.

<br/>

## 4단계: 다형성을 활용해 계산 코드 재구성하기

> 조건부 로직을 다형성으로 바꾸기 <br/>
> : 조건부 코드 한 덩어리를 다형성을 활용하는 방식으로 바꿔준다.

- 공연료 계산기 만들기
    - 담당 클래스 생성하기
    - 함수 선언 바꾸기를 적용하여 생성자에 필드 전달하기
- 함수들을 계산기로 옮기기
  - 함수들을 담당 클래스로 위치 이임
  - 원본 함수가 이동한 함수로 작업을 위임하도록 수거
  - 원본 함수 인라인
- 공연료 계산기를 다형성 버전으로 만들기
  - 생성자를 팩터리 함수로 바꾸기
  - 타입 코드를 서브 클래스로 바꾸기
  - 조건부 로직을 다형성으로 바꾸기

> 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
